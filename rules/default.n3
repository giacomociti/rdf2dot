@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix v: <http://view/> .
@prefix attr: <http://view/dot/attribute/> .

# all the subjects of some triple become nodes
{
  ?s ?p ?o .
  # to avoid loops, skip subjects that are nodes or edges
  ( ?x { ?s a v:Edge } () ) log:collectAllIn [] .
  ( ?x { ?s a v:Node } () ) log:collectAllIn [] .
}
=>
{
  [] a v:Node ;
    v:term ?s
}.

# all properties connecting two nodes become edges
{     
  ?s ?p ?o .
  ?source a v:Node ; v:term ?s .
  ?target a v:Node ; v:term ?o .
}
=>
{
  [] a v:Edge ;      
     v:source ?source ;
     v:target ?target ;
     v:term ?p ;
}.

{ 
    ?n a v:Node ; v:term ?s .
    ?s log:uri ?tooltip .
}
=>
{
    ?n attr:tooltip ?tooltip
}.

# edges use local name as label and URI as tooltop
{
  ?l a v:Edge ; 
    v:term ?p .
  ?p log:localName ?label ;
    log:uri ?tooltip .
}
=> 
{
  ?l attr:label ?label ;
    attr:tooltip ?tooltip .
}
.

# collect literal properties as node fields
{ 
    ?n a v:Node ; v:term ?s .
    ?s ?p ?o .
    (?fieldValue ?dataType) log:dtlit ?o . # ensure is literal
    ?p log:localName ?fieldName .
    ( "%s: %s" ?fieldName ?fieldValue) string:format ?field
} 
=> 
{ 
    ?n v:field ?field .
} .

# # collect language literal properties as node fields
# { 
#     ?n a v:Node ; v:term ?s .
#     ?s ?p ?o .
#     (?fieldValue ?lang) log:langlit ?o . # ensure is literal
#     ?p log:localName ?fieldName .
#     ( "%s (%s): %s" ?fieldName ?lang ?fieldValue) string:format ?field
# } 
# => 
# { 
#     ?n v:field ?field ;
# } .

# collect fields for uri properties with objects which are not nodes
{
    ?s ?p ?o .
    ?o log:uri ?u .
    ?o log:localName ?fieldValue .
    (?po {?o ?po ?oo } ()) log:collectAllIn [] .
    ?p log:localName ?fieldName .
    ?n a v:Node ; v:term ?s .
    ( "%s: %s" ?fieldName ?fieldValue) string:format ?field
}
=>
{
    ?n v:field ?field ;
}.

# if a node has some fields, shape it as a record with the fields as a label
{
    ?s a v:Node .
    ( ?f { ?s v:field ?f } ?fs ) log:collectAllIn [] .
    ?fs log:notEqualTo () .
    (?fs "|") string:join ?joined .
    ( "{%s}" ?joined) string:format ?label
}
=>
{
    ?s attr:shape "Mrecord" .
    ?s attr:label ?label
}
.

{
    ( ?p { [] a v:Edge ; v:term ?p } ?ps ) log:collectAllIn [] .
    ?ps list:iterate (?i ?prop) .
    (?i 1) math:sum ?color .
    ?l v:term ?prop .
}
=>
{
    ?l attr:color ?color
}.