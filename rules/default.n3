@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix v: <http://view/> .
@prefix attr: <http://view/dot/attribute/> .

# all the subjects of some triple become nodes
{
  ?s ?p ?o .
  # to avoid loops, skip subjects that are nodes or edges
  [] log:notIncludes { ?s a v:Node } .
  [] log:notIncludes { ?s a v:Edge } .
  ?s log:notEqualTo v:graph, v:edge , v:node .
}
=>
{
  [] a v:Node ; v:term ?s
}.

# all properties connecting two nodes become edges
{     
  ?s ?p ?o .
  ?source a v:Node ; v:term ?s .
  ?target a v:Node ; v:term ?o .
}
=>
{
  [] a v:Edge ;      
     v:source ?source ;
     v:target ?target ;
     v:term ?p ;
}.

# node tooltips and URLs
{ 
    ?n a v:Node ; v:term ?term .
    ?term log:rawType [ log:notEqualTo log:LabeledBlankNode  , log:UnlabeledBlankNode ] .
    ?term  log:uri ?uri .
}
=>
{
    ?n attr:tooltip ?uri ; attr:URL ?uri
}.



# edge labels, tooltips and URLs
{
  ?e a v:Edge ; v:term [ log:localName ?name ; log:uri ?uri ]
}
=> 
{
  ?e attr:label ?name ; attr:tooltip ?name ; attr:labelURL ?uri .
}
.

# collect literal properties as node fields
{ 
    ?n a v:Node ; v:term [ ?p ?o ] .
    (?fieldValue ?dataType) log:dtlit ?o . # ensure is literal
    ?p log:localName ?fieldName .

    (   ?fieldValue
        ("&" "<" ">" '"') 
        ("&amp;" "&lt;" "&gt;" "&quot;")
    ) string:replaceAll ?escapedValue .

    ( "<TR><TD><I>%s</I></TD><TD>%s</TD></TR>" ?fieldName ?escapedValue) string:format ?field
} 
=> 
{ 
    ?n v:field ?field .
} .

# # collect language literal properties as node fields
# { 
#     ?n a v:Node ; v:term ?s .
#     ?s ?p ?o .
#     (?fieldValue ?lang) log:langlit ?o . # ensure is literal
#     ?p log:localName ?fieldName .
#     ( "%s (%s): %s" ?fieldName ?lang ?fieldValue) string:format ?field
# } 
# => 
# { 
#     ?n v:field ?field ;
# } .

# collect fields for uri properties with objects which are not nodes
{
    ?n a v:Node ; v:term [ ?p ?o ] .
    ?o log:uri [] .
    [] log:notIncludes { ?o [] [] } .
    ?p log:localName ?fieldName .
    ?o log:localName ?fieldValue .
   
    (   ?fieldValue
        ("&" "<" ">" '"')
        ("&amp;" "&lt;" "&gt;" "&quot;")
    ) string:replaceAll ?escapedValue .

    ( "<TR><TD><I>%s</I></TD><TD>%s</TD></TR>" ?fieldName ?escapedValue) string:format ?field
}
=>
{
    ?n v:field ?field ;
}
.

# if a node has fields, its label is a table with the fields as rows
{
    ?s a v:Node .
    ( ?f { ?s v:field ?f } ?fs ) log:collectAllIn [] .
    ?fs log:notEqualTo () .
    (?fs "\n") string:join ?joined .
    ( '< <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">\n%s\n</TABLE> >' ?joined) string:format ?label
}
=>
{
    ?s attr:shape "plaintext" ; attr:label ?label
}
.



# lists
{ ?s ?p ?o . ?o log:rawType rdf:List } => { [] a v:Node ; v:term ?o } .

{
    ?n a v:Node ; v:term ?list .
    ?list log:rawType rdf:List .
    ?list list:iterate (?i ?item) .

    ("%s" ?item) string:format ?fieldValue .
    (   ?fieldValue
        ("&" "<" ">" '"') 
        ("&amp;" "&lt;" "&gt;" "&quot;")
    ) string:replaceAll ?escapedValue .

    ( '<TR><TD PORT="%s">%s</TD></TR>' ?i ?escapedValue) string:format ?field
}
=> 
{
    ?n v:field ?field
}
.

{
    ?source a v:Node ; v:term ?list .
    ?list log:rawType rdf:List .
    ?list list:iterate (?i ?item) .
    ?target a v:Node ; v:term ?item .
}
=> 
{
    [] a v:Edge ; v:source ?source ; v:sourcePort ?i ; v:target ?target ; 
    
}
.

# edge coloring
{
    (?p { [] a v:Edge ; v:term ?p } ?ps) log:collectAllIn [] .
    ?ps list:iterate (?i ?prop) .
    (?i 1) math:sum ?color .
    ?edge v:term ?prop .
}
=>
{
    ?edge attr:color ?color
}
.

{ } => { v:edge attr:colorscheme "paired12" } .