@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix v: <http://view/> .
@prefix attr: <http://view/dot/attribute/> .

# all the subjects of some triple become nodes
{
    ?s ?p ?o .
    # to avoid loops
    ?p log:namespace ?ns .
    v: log:uri [ log:notEqualTo ?ns ] .
    attr: log:uri [ log:notEqualTo ?ns ] .
}
=>
{
    v:digraph v:hasNode [ v:term ?s ] .
}.

# all properties connecting two nodes become edges
{     
    ?s ?p ?o .
    ?source v:term ?s .
    ?target v:term ?o .
}
=>
{
    v:digraph v:hasEdge [ v:source ?source ; v:target ?target ; v:term ?p ] .
}.

# node tooltips and URLs
{ 
    v:digraph v:hasNode ?n .
    ?n v:term ?term .
    ?term log:rawType [ log:notEqualTo log:LabeledBlankNode , log:UnlabeledBlankNode ] .
    ?term  log:uri ?uri .
}
=>
{
    ?n attr:tooltip ?uri ; attr:URL ?uri
}.



# edge labels, tooltips and URLs
{
    v:digraph v:hasEdge ?e .
    ?e v:term [ log:localName ?name ; log:uri ?uri ]
}
=> 
{
    ?e attr:label ?name ; attr:tooltip ?name ; attr:labelURL ?uri .
}
.

# collect literal properties as node fields
{ 
    v:digraph v:hasNode ?n .
    ?n v:term [ ?p ?o ] .
    (?fieldValue ?dataType) log:dtlit ?o . # ensure is literal
    ?p log:localName ?fieldName .

    (   ?fieldValue
        ("&" "<" ">" '"') 
        ("&amp;" "&lt;" "&gt;" "&quot;")
    ) string:replaceAll ?escapedValue .

    ( "<TR><TD><I>%s</I></TD><TD>%s</TD></TR>" ?fieldName ?escapedValue) string:format ?field
} 
=> 
{ 
    ?n v:field ?field .
} .


# collect fields for uri properties with objects which are not nodes
{
    v:digraph v:hasNode ?n .
    ?n v:term [ ?p ?o ] .
    ?o log:uri [] .
    [] log:notIncludes { ?o [] [] } .
    ?p log:localName ?fieldName .
    ?o log:localName ?fieldValue .
   
    (   ?fieldValue
        ("&" "<" ">" '"')
        ("&amp;" "&lt;" "&gt;" "&quot;")
    ) string:replaceAll ?escapedValue .

    ( "<TR><TD><I>%s</I></TD><TD>%s</TD></TR>" ?fieldName ?escapedValue) string:format ?field
}
=>
{
    ?n v:field ?field ;
}
.

# if a node has fields, its label is a table with the fields as rows
{
    v:digraph v:hasNode ?s .
    ( ?f { ?s v:field ?f } ?fs ) log:collectAllIn [] .
    ?fs log:notEqualTo () .
    (?fs "\n") string:join ?joined .
    ( '< <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">\n%s\n</TABLE> >' ?joined) string:format ?label
}
=>
{
    ?s attr:shape "plaintext" ; attr:label ?label
}
.



# lists
{ ?s ?p ?o . ?o log:rawType rdf:List } => { v:digraph v:hasNode [ v:term ?o ] } .

{
    v:digraph v:hasNode ?n .
    ?n v:term ?list .
    ?list log:rawType rdf:List .
    ?list list:iterate (?i ?item) .

    ("%s" ?item) string:format ?fieldValue .
    (   ?fieldValue
        ("&" "<" ">" '"') 
        ("&amp;" "&lt;" "&gt;" "&quot;")
    ) string:replaceAll ?escapedValue .

    ( '<TR><TD PORT="%s">%s</TD></TR>' ?i ?escapedValue) string:format ?field
}
=> 
{
    ?n v:field ?field
}
.

{
    v:digraph v:hasNode ?source .
    ?source v:term ?list .
    ?list log:rawType rdf:List .
    ?list list:iterate (?i ?item) .
    v:digraph v:hasNode ?target .
    ?target v:term ?item .
}
=> 
{
    v:digraph v:hasEdge [ v:source ?source ; v:sourcePort ?i ; v:target ?target ] .    
}
.

# edge coloring
{
    (?p { v:digraph v:hasEdge [ v:term ?p ] } ?ps) log:collectAllIn [] .
    ?ps list:iterate (?i ?prop) .
    (?i 1) math:sum ?color .
    ?edge v:term ?prop .
}
=>
{
    ?edge attr:color ?color
}
.

{ } => { v:digraph v:edgeAttributes [ attr:colorscheme "paired12" ]  } .