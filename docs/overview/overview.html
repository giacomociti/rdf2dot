<html>
    <body>
        <script src="https://unpkg.com/n3/browser/n3.min.js"></script>
        <script src="https://eyereasoner.github.io/eye-js/2/latest/index.js"></script>
        <script src="https://d3js.org/d3.v7.js"></script>
        <script src="https://unpkg.com/@hpcc-js/wasm@2/dist/graphviz.umd.js"></script>
        <script src="https://unpkg.com/d3-graphviz@5/build/d3-graphviz.js"></script>
        <script src="toDot.js"></script>

        <script>
            const convertToDot = toDot(window.N3.DataFactory)

            const fetchText = async file => {
                const response = await fetch(file)
                const text = await response.text()
                return text
            }

            const load = async (file, element) => {
                const text = await fetchText(file)
                document.getElementById(element).innerText = text
            }
    
            const run = async (dataFile, ruleFile, graphId) => {
                const [data, rules] = await Promise.all([dataFile, ruleFile].map(fetchText))
                await runText(data, rules, graphId)
            }

            const runText = async (data, rules, graphId) => {
               const { SwiplEye, queryOnce } = eyereasoner
               const chunks = []
               const Module = await SwiplEye({ print: x => { chunks.push(x) }, arguments: ['-q'] })
               Module.FS.writeFile('data.ttl', data)
               Module.FS.writeFile('rules.n3', rules)
               queryOnce(Module, 'main', ['--nope', '--quiet', './rules.n3', '--turtle', './data.ttl', '--pass-only-new']);
               const result = chunks.join('\n')
               console.log(result)
               await show(result, graphId)
           }

            const show = async (diagramText, graphId) => {
                const quads = new N3.Parser().parse(diagramText)
                const dot = await convertToDot(new N3.Store(quads))
                console.log(dot)
                d3.select(graphId)
                    .graphviz({useWorker: false})
                    .renderDot(dot)
            }
        
        </script>
        <h1>Diagrams for RDF data</h1>
        <p>
            RDF data naturally represent graphs, and visualizing them is straightforward with diagramming tools like <a href="https://www.graphviz.org/">Graphviz</a>.
            A generic mapping can turn each triple into a link between a node for the subject and a node for the object. For example:
        </p>

        <table>
            <tr>
                <td><pre id="data1"></pre></td>
                <td><div id="graph1" style="text-align: center;"></div></td>
            </tr>
        </table>
        <script>load("data1.ttl", "data1")</script>
        <script>run("data1.ttl", "rules1.n3", "#graph1")</script>
        
        <p>But such diagrams quickly become messy for non-trivial data, unless we can tweak them a little bit.</p>
        <p>
            To have decent-looking diagrams, we inevitably have to cope with long URIs, maybe keeping them as tooltips but using something else for labels.
            To have fewer links, some literal properties may be ignored, and others may be embedded in the label for their subject. 
            The same embedding may sometimes be useful for object properties (like <code>rdf:type</code> declarations).
            Link labels may be omitted and colors may help to at least distinguish links that represent different predicates.
            Node shapes and colors may represent the type, the value of some other property, or even a combination.
        </p>
        <p>
            But even if we can settle on a good default set of visualization rules like these, it is important to be able to cherry pick rules and to add more specific ones on a diagram-by-diagram basis.
            The approach proposed here (which is <a href="https://www.w3.org/2001/02pd/">not new</a>) provides the needed flexibility to tailor graph diagrams of RDF data.</p>

        <h3>Diagramming Vocabulary</h3>
        <p>
            Using a small vocabulary of basic diagramming terms (node, link, label, shape, color, tooltip...) we can express a diagram in RDF.
            Converting such diagram descriptions from RDF to some diagramming DSL like <a href="https://www.graphviz.org/doc/info/lang.html">dot</a> 
            is not difficult (see <a href="toDot.js">toDot.js</a> which is the code actually used for this page).
        </p>       
        <p>With our vocabulary, we can describe a more compact version of the above graph:</p>
        <table>
            <tr>
                <td><pre id="diagram2"></pre></td>
                <td><div id="graph2" style="text-align: center;"></div></td>
            </tr>
        </table>
        <script>load("diagram2.ttl", "diagram2")</script>
        <script>fetchText("diagram2.ttl").then(x => show(x, "#graph2"))</script>

        <p>The label for the <code>ann</code> node is the name instead of the URI. The shape for the city node is rectangular, 
            and its label is only the last part of the URI. The label of the link is also customized, 
            but the full property URI is available as a tooltip over the arrow.
        </p>
        <p>
            Thus we can construct a customized diagram for our little dataset. But if we were to create the diagram description manually, it would be better to use directly the <em>dot</em> language which is designed for that purpose.
        </p>

        <p>The missing step is how to get from the original data to the description of its diagram. 
        We need rules to tranform RDF data into diagram descriptions. Some rules may be more general (<em>the tooltip of an arrow is the property URI</em>), 
        others a bit more specific (<em>city nodes are rectangular</em>).

        </p>
        <p>Since it's a matter of transforming an RDF dataset into another RDF dataset, 
            one option is to use SPARQL and run a CONSTRUCT query to transform the original RDF data into the desired description of its diagram.
        </p>
        <p>But here, as in the <a href="https://www.w3.org/2001/02pd/">original idea</a>, we leverage <a href="https://w3c.github.io/N3/reports/20230703/">Notation 3</a>
        and its <a href="https://github.com/eyereasoner"> eye reasoner</a> implementation now available also <a href="https://github.com/eyereasoner/eye-js"></a>in the browser.</p>
    
        <h3>Notation 3</h3>
        <p>The following N3 rules are used to obtain the last diagram from the initial data:</p>

        <pre id="rules2"></pre>
        <script>load("rules2.n3", "rules2")</script>
        <p>There are three rules, expressed with the implication symbol =>. </p>
        <li>
            The first one states that for every instance of city, we extract the last part of its URI
            (using a so-called built-in function named <code>log:localName</code>) and derive an instance
            of node with such a label and having rectangular shape.
        </li>
        <li>
            The next rule handles triples with a string literal value for the <code>urn:name</code> predicate.
            The subject of such a triple becomes a node labelled with the literal value 
            (the text part of the literal term is parsed by the <code>log:dtlit</code> built-in).
        </li>
        <li>
            The last rule creates links for the <code>urn:livesIn</code> property, with a customized label
            and the tooltip obtained from the URI (converted to string by the <code>log:uri</code> built-in).
        </li>
        <p>
            The above rules are quite specific and tailored to the vocabulary used in the input data.
            Any additional data not covered by the rules would be ignored.
            It is possible to create more general rules, such that all input data would somehow be mapped to a diagrammatic
            representation. In fact the very first diagram was obtained with a simple general-purpose rule:
        </p>
        <pre id="rules1"></pre>
        <script>load("rules1.n3", "rules1")</script>
        
        <p>
            It is possible to create and compose both general and specific rules.
            General rules may require extra-care, for example the <code>log:notEqualTo</code> clauses above are needed to
            avoid loops (otherwise the rule would be applied also to the derived triples).

            A sufficient understanding of Notation 3 logic is needed, but it allows to create interesting diagrams.
        </p>

       
    </body>
</html>


