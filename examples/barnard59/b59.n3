@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix v: <http://view/> .
@prefix attr: <http://view/dot/attribute/> .
@prefix code: <https://code.described.at/>.
@prefix p: <https://pipeline.described.at/>.
@prefix op: <http://barnard59.zazuko.com/operations/>.
@prefix temp: <http://org/temp/>.

# colors...
temp:pipeline temp:colors ("blue" "red" "green" "orange" "yellow" "pink") .

# each pipeline has a color
{
    (?p {?p a p:Pipeline} ?ps) log:collectAllIn [] .
    ?ps list:iterate (?index ?item) .
    temp:pipeline temp:colors ?colors .
    (?colors ?index) list:memberAt ?color .
} 
=> 
{
    ?item a v:Node ; attr:color ?color .
}.

# use local name as label
{ ?p a p:Pipeline; log:localName ?name } => { ?p attr:label ?name } .

# fist step in a pipeline has link with same color
{
    ?p a p:Pipeline; attr:color ?color; p:steps [ p:stepList [list:first ?first] ].
} 
=>
{
    ?first a v:Node .
    [] a v:Edge; v:source ?p; v:target ?first; attr:color ?color
}
.

# each step in a pipeline has link with same color
{
    ?p a p:Pipeline; attr:color ?color; p:steps [ p:stepList ?steps ] .
    ?steps list:iterate (?i ?step) .
    (?i 1) math:sum ?pos .
    (?steps ?pos) list:memberAt ?next .
} 
=>
{
    ?next a v:Node .
    [] a v:Edge; v:source ?step; v:target ?next; attr:color ?color .
}
.

# step label based on its implementation
{ 
    ?s a p:Step; code:implementedBy [ code:link ?code ] .
    ?code log:uri ?codeUri .
    ( '<TR><TD COLSPAN="2"><I>%s</I></TD></TR>' ?codeUri) string:format ?field .
}
=>
{ 
    # ?s attr:label ?label
    ?s v:field ?field
}
.

# link arguments that are sub-pipelines
{
    ?n code:arguments [list:member ?arg] .
    ?arg a p:Pipeline
}
=>
{
    [] a v:Edge; v:source ?n; v:target ?arg; attr:arrowhead "inv"; attr:style "dashed".
}
.

# link named arguments that are sub-pipelines
{
    ?n code:arguments [code:name ?name; code:value ?value] .
    ?value a p:Pipeline .
}
=>
{
    [] a v:Edge; v:source ?n; v:target ?value; attr:label ?name; attr:arrowhead "inv"; attr:style "dashed".
}
.


# collect literal arguments
{
    ?n code:arguments [list:member ?arg] .
    (?v ?typ) log:dtlit ?arg .
    ?typ log:localName ?t .

    (?v
        ("&" "<" ">" '"') 
        ("&amp;" "&lt;" "&gt;" "&quot;")
    ) string:replaceAll ?escaped .

    ( '<TR><TD>%s (%s)</TD></TR>' ?escaped ?t) string:format ?field .

}
=>
{
    ?n v:field ?field
}
.

# collect named literal arguments
{
    ?n code:arguments [code:name ?name; code:value ?value] .
    (?v ?typ) log:dtlit ?value .
    ?typ log:localName ?t .

    (?v
        ("&" "<" ">" '"') 
        ("&amp;" "&lt;" "&gt;" "&quot;")
    ) string:replaceAll ?escaped .

    ( "<TR><TD><I>%s</I></TD><TD>%s (%s)</TD></TR>" ?name ?escaped ?t) string:format ?field .# todo include ?name
}
=>
{
    ?n v:field ?field
}
.

# if a node has some fields, shape it as a table with the fields as rows
{
    ?s a v:Node .
    ( ?f { ?s v:field ?f } ?fs ) log:collectAllIn [] .
    ?fs log:notEqualTo () .
    (?fs "\n") string:join ?joined .
    ( '< <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">\n%s\n</TABLE> >' ?joined) string:format ?label
}
=>
{
    ?s attr:shape "plaintext" .
    ?s attr:label ?label
}
.